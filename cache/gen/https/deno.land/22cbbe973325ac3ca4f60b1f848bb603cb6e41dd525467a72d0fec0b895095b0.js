import { dirname, extname, fromFileUrl, gte, join, toFileUrl, walk } from "./deps.ts";
import { error } from "./error.ts";
const MIN_DENO_VERSION = "1.25.0";
export function ensureMinDenoVersion() {
    // Check that the minimum supported Deno version is being used.
    if (!gte(Deno.version.deno, MIN_DENO_VERSION)) {
        let message = `Deno version ${MIN_DENO_VERSION} or higher is required. Please update Deno.\n\n`;
        if (Deno.execPath().includes("homebrew")) {
            message += "You seem to have installed Deno via homebrew. To update, run: `brew upgrade deno`\n";
        } else {
            message += "To update, run: `deno upgrade`\n";
        }
        error(message);
    }
}
export async function collect(directory) {
    const routesDir = join(directory, "./routes");
    const islandsDir = join(directory, "./islands");
    const routes = [];
    try {
        const routesUrl = toFileUrl(routesDir);
        // TODO(lucacasonato): remove the extranious Deno.readDir when
        // https://github.com/denoland/deno_std/issues/1310 is fixed.
        for await (const _ of Deno.readDir(routesDir)){
        // do nothing
        }
        const routesFolder = walk(routesDir, {
            includeDirs: false,
            includeFiles: true,
            exts: [
                "tsx",
                "jsx",
                "ts",
                "js"
            ]
        });
        for await (const entry of routesFolder){
            if (entry.isFile) {
                const file = toFileUrl(entry.path).href.substring(routesUrl.href.length);
                routes.push(file);
            }
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
        // Do nothing.
        } else {
            throw err;
        }
    }
    routes.sort();
    const islands = [];
    try {
        const islandsUrl = toFileUrl(islandsDir);
        for await (const entry1 of Deno.readDir(islandsDir)){
            if (entry1.isDirectory) {
                error(`Found subdirectory '${entry1.name}' in islands/. The islands/ folder must not contain any subdirectories.`);
            }
            if (entry1.isFile) {
                const ext = extname(entry1.name);
                if (![
                    ".tsx",
                    ".jsx",
                    ".ts",
                    ".js"
                ].includes(ext)) continue;
                const path = join(islandsDir, entry1.name);
                const file1 = toFileUrl(path).href.substring(islandsUrl.href.length);
                islands.push(file1);
            }
        }
    } catch (err1) {
        if (err1 instanceof Deno.errors.NotFound) {
        // Do nothing.
        } else {
            throw err1;
        }
    }
    islands.sort();
    return {
        routes,
        islands
    };
}
export async function generate(directory, manifest) {
    const { routes , islands  } = manifest;
    const output = `// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

import config from "./deno.json" assert { type: "json" };
${routes.map((file, i)=>`import * as $${i} from "./routes${file}";`).join("\n")}
${islands.map((file, i)=>`import * as $$${i} from "./islands${file}";`).join("\n")}

const manifest = {
  routes: {
    ${routes.map((file, i)=>`${JSON.stringify(`./routes${file}`)}: $${i},`).join("\n    ")}
  },
  islands: {
    ${islands.map((file, i)=>`${JSON.stringify(`./islands${file}`)}: $$${i},`).join("\n    ")}
  },
  baseUrl: import.meta.url,
  config,
};

export default manifest;
`;
    const proc = Deno.run({
        cmd: [
            Deno.execPath(),
            "fmt",
            "-"
        ],
        stdin: "piped",
        stdout: "piped",
        stderr: "null"
    });
    const raw = new ReadableStream({
        start (controller) {
            controller.enqueue(new TextEncoder().encode(output));
            controller.close();
        }
    });
    await raw.pipeTo(proc.stdin.writable);
    const out = await proc.output();
    await proc.status();
    proc.close();
    const manifestStr = new TextDecoder().decode(out);
    const manifestPath = join(directory, "./fresh.gen.ts");
    await Deno.writeTextFile(manifestPath, manifestStr);
    console.log(`%cThe manifest has been generated for ${routes.length} routes and ${islands.length} islands.`, "color: blue; font-weight: bold");
}
export async function dev(base, entrypoint) {
    ensureMinDenoVersion();
    entrypoint = new URL(entrypoint, base).href;
    const dir = dirname(fromFileUrl(base));
    let currentManifest;
    const prevManifest = Deno.env.get("FRSH_DEV_PREVIOUS_MANIFEST");
    if (prevManifest) {
        currentManifest = JSON.parse(prevManifest);
    } else {
        currentManifest = {
            islands: [],
            routes: []
        };
    }
    const newManifest = await collect(dir);
    Deno.env.set("FRSH_DEV_PREVIOUS_MANIFEST", JSON.stringify(newManifest));
    const manifestChanged = !arraysEqual(newManifest.routes, currentManifest.routes) || !arraysEqual(newManifest.islands, currentManifest.islands);
    if (manifestChanged) await generate(dir, newManifest);
    await import(entrypoint);
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; ++i){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZnJlc2hAMS4xLjIvc3JjL2Rldi9tb2QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZGlybmFtZSxcbiAgZXh0bmFtZSxcbiAgZnJvbUZpbGVVcmwsXG4gIGd0ZSxcbiAgam9pbixcbiAgdG9GaWxlVXJsLFxuICB3YWxrLFxufSBmcm9tIFwiLi9kZXBzLnRzXCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuL2Vycm9yLnRzXCI7XG5cbmNvbnN0IE1JTl9ERU5PX1ZFUlNJT04gPSBcIjEuMjUuMFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlTWluRGVub1ZlcnNpb24oKSB7XG4gIC8vIENoZWNrIHRoYXQgdGhlIG1pbmltdW0gc3VwcG9ydGVkIERlbm8gdmVyc2lvbiBpcyBiZWluZyB1c2VkLlxuICBpZiAoIWd0ZShEZW5vLnZlcnNpb24uZGVubywgTUlOX0RFTk9fVkVSU0lPTikpIHtcbiAgICBsZXQgbWVzc2FnZSA9XG4gICAgICBgRGVubyB2ZXJzaW9uICR7TUlOX0RFTk9fVkVSU0lPTn0gb3IgaGlnaGVyIGlzIHJlcXVpcmVkLiBQbGVhc2UgdXBkYXRlIERlbm8uXFxuXFxuYDtcblxuICAgIGlmIChEZW5vLmV4ZWNQYXRoKCkuaW5jbHVkZXMoXCJob21lYnJld1wiKSkge1xuICAgICAgbWVzc2FnZSArPVxuICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgaW5zdGFsbGVkIERlbm8gdmlhIGhvbWVicmV3LiBUbyB1cGRhdGUsIHJ1bjogYGJyZXcgdXBncmFkZSBkZW5vYFxcblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IFwiVG8gdXBkYXRlLCBydW46IGBkZW5vIHVwZ3JhZGVgXFxuXCI7XG4gICAgfVxuXG4gICAgZXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1hbmlmZXN0IHtcbiAgcm91dGVzOiBzdHJpbmdbXTtcbiAgaXNsYW5kczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2xsZWN0KGRpcmVjdG9yeTogc3RyaW5nKTogUHJvbWlzZTxNYW5pZmVzdD4ge1xuICBjb25zdCByb3V0ZXNEaXIgPSBqb2luKGRpcmVjdG9yeSwgXCIuL3JvdXRlc1wiKTtcbiAgY29uc3QgaXNsYW5kc0RpciA9IGpvaW4oZGlyZWN0b3J5LCBcIi4vaXNsYW5kc1wiKTtcblxuICBjb25zdCByb3V0ZXMgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCByb3V0ZXNVcmwgPSB0b0ZpbGVVcmwocm91dGVzRGlyKTtcbiAgICAvLyBUT0RPKGx1Y2FjYXNvbmF0byk6IHJlbW92ZSB0aGUgZXh0cmFuaW91cyBEZW5vLnJlYWREaXIgd2hlblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9pc3N1ZXMvMTMxMCBpcyBmaXhlZC5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgRGVuby5yZWFkRGlyKHJvdXRlc0RpcikpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgY29uc3Qgcm91dGVzRm9sZGVyID0gd2Fsayhyb3V0ZXNEaXIsIHtcbiAgICAgIGluY2x1ZGVEaXJzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVGaWxlczogdHJ1ZSxcbiAgICAgIGV4dHM6IFtcInRzeFwiLCBcImpzeFwiLCBcInRzXCIsIFwianNcIl0sXG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiByb3V0ZXNGb2xkZXIpIHtcbiAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRvRmlsZVVybChlbnRyeS5wYXRoKS5ocmVmLnN1YnN0cmluZyhcbiAgICAgICAgICByb3V0ZXNVcmwuaHJlZi5sZW5ndGgsXG4gICAgICAgICk7XG4gICAgICAgIHJvdXRlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIERlbm8uZXJyb3JzLk5vdEZvdW5kKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIHJvdXRlcy5zb3J0KCk7XG5cbiAgY29uc3QgaXNsYW5kcyA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IGlzbGFuZHNVcmwgPSB0b0ZpbGVVcmwoaXNsYW5kc0Rpcik7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBEZW5vLnJlYWREaXIoaXNsYW5kc0RpcikpIHtcbiAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBgRm91bmQgc3ViZGlyZWN0b3J5ICcke2VudHJ5Lm5hbWV9JyBpbiBpc2xhbmRzLy4gVGhlIGlzbGFuZHMvIGZvbGRlciBtdXN0IG5vdCBjb250YWluIGFueSBzdWJkaXJlY3Rvcmllcy5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICBjb25zdCBleHQgPSBleHRuYW1lKGVudHJ5Lm5hbWUpO1xuICAgICAgICBpZiAoIVtcIi50c3hcIiwgXCIuanN4XCIsIFwiLnRzXCIsIFwiLmpzXCJdLmluY2x1ZGVzKGV4dCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBwYXRoID0gam9pbihpc2xhbmRzRGlyLCBlbnRyeS5uYW1lKTtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRvRmlsZVVybChwYXRoKS5ocmVmLnN1YnN0cmluZyhpc2xhbmRzVXJsLmhyZWYubGVuZ3RoKTtcbiAgICAgICAgaXNsYW5kcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIERlbm8uZXJyb3JzLk5vdEZvdW5kKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlzbGFuZHMuc29ydCgpO1xuXG4gIHJldHVybiB7IHJvdXRlcywgaXNsYW5kcyB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGUoZGlyZWN0b3J5OiBzdHJpbmcsIG1hbmlmZXN0OiBNYW5pZmVzdCkge1xuICBjb25zdCB7IHJvdXRlcywgaXNsYW5kcyB9ID0gbWFuaWZlc3Q7XG5cbiAgY29uc3Qgb3V0cHV0ID0gYC8vIERPIE5PVCBFRElULiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGZyZXNoLlxuLy8gVGhpcyBmaWxlIFNIT1VMRCBiZSBjaGVja2VkIGludG8gc291cmNlIHZlcnNpb24gY29udHJvbC5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgZHVyaW5nIGRldmVsb3BtZW50IHdoZW4gcnVubmluZyBcXGBkZXYudHNcXGAuXG5cbmltcG9ydCBjb25maWcgZnJvbSBcIi4vZGVuby5qc29uXCIgYXNzZXJ0IHsgdHlwZTogXCJqc29uXCIgfTtcbiR7XG4gICAgcm91dGVzLm1hcCgoZmlsZSwgaSkgPT4gYGltcG9ydCAqIGFzICQke2l9IGZyb20gXCIuL3JvdXRlcyR7ZmlsZX1cIjtgKS5qb2luKFxuICAgICAgXCJcXG5cIixcbiAgICApXG4gIH1cbiR7XG4gICAgaXNsYW5kcy5tYXAoKGZpbGUsIGkpID0+IGBpbXBvcnQgKiBhcyAkJCR7aX0gZnJvbSBcIi4vaXNsYW5kcyR7ZmlsZX1cIjtgKVxuICAgICAgLmpvaW4oXCJcXG5cIilcbiAgfVxuXG5jb25zdCBtYW5pZmVzdCA9IHtcbiAgcm91dGVzOiB7XG4gICAgJHtcbiAgICByb3V0ZXMubWFwKChmaWxlLCBpKSA9PiBgJHtKU09OLnN0cmluZ2lmeShgLi9yb3V0ZXMke2ZpbGV9YCl9OiAkJHtpfSxgKVxuICAgICAgLmpvaW4oXCJcXG4gICAgXCIpXG4gIH1cbiAgfSxcbiAgaXNsYW5kczoge1xuICAgICR7XG4gICAgaXNsYW5kcy5tYXAoKGZpbGUsIGkpID0+IGAke0pTT04uc3RyaW5naWZ5KGAuL2lzbGFuZHMke2ZpbGV9YCl9OiAkJCR7aX0sYClcbiAgICAgIC5qb2luKFwiXFxuICAgIFwiKVxuICB9XG4gIH0sXG4gIGJhc2VVcmw6IGltcG9ydC5tZXRhLnVybCxcbiAgY29uZmlnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWFuaWZlc3Q7XG5gO1xuXG4gIGNvbnN0IHByb2MgPSBEZW5vLnJ1bih7XG4gICAgY21kOiBbRGVuby5leGVjUGF0aCgpLCBcImZtdFwiLCBcIi1cIl0sXG4gICAgc3RkaW46IFwicGlwZWRcIixcbiAgICBzdGRvdXQ6IFwicGlwZWRcIixcbiAgICBzdGRlcnI6IFwibnVsbFwiLFxuICB9KTtcbiAgY29uc3QgcmF3ID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG91dHB1dCkpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0sXG4gIH0pO1xuICBhd2FpdCByYXcucGlwZVRvKHByb2Muc3RkaW4ud3JpdGFibGUpO1xuICBjb25zdCBvdXQgPSBhd2FpdCBwcm9jLm91dHB1dCgpO1xuICBhd2FpdCBwcm9jLnN0YXR1cygpO1xuICBwcm9jLmNsb3NlKCk7XG5cbiAgY29uc3QgbWFuaWZlc3RTdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0KTtcbiAgY29uc3QgbWFuaWZlc3RQYXRoID0gam9pbihkaXJlY3RvcnksIFwiLi9mcmVzaC5nZW4udHNcIik7XG5cbiAgYXdhaXQgRGVuby53cml0ZVRleHRGaWxlKG1hbmlmZXN0UGF0aCwgbWFuaWZlc3RTdHIpO1xuICBjb25zb2xlLmxvZyhcbiAgICBgJWNUaGUgbWFuaWZlc3QgaGFzIGJlZW4gZ2VuZXJhdGVkIGZvciAke3JvdXRlcy5sZW5ndGh9IHJvdXRlcyBhbmQgJHtpc2xhbmRzLmxlbmd0aH0gaXNsYW5kcy5gLFxuICAgIFwiY29sb3I6IGJsdWU7IGZvbnQtd2VpZ2h0OiBib2xkXCIsXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXYoYmFzZTogc3RyaW5nLCBlbnRyeXBvaW50OiBzdHJpbmcpIHtcbiAgZW5zdXJlTWluRGVub1ZlcnNpb24oKTtcblxuICBlbnRyeXBvaW50ID0gbmV3IFVSTChlbnRyeXBvaW50LCBiYXNlKS5ocmVmO1xuXG4gIGNvbnN0IGRpciA9IGRpcm5hbWUoZnJvbUZpbGVVcmwoYmFzZSkpO1xuXG4gIGxldCBjdXJyZW50TWFuaWZlc3Q6IE1hbmlmZXN0O1xuICBjb25zdCBwcmV2TWFuaWZlc3QgPSBEZW5vLmVudi5nZXQoXCJGUlNIX0RFVl9QUkVWSU9VU19NQU5JRkVTVFwiKTtcbiAgaWYgKHByZXZNYW5pZmVzdCkge1xuICAgIGN1cnJlbnRNYW5pZmVzdCA9IEpTT04ucGFyc2UocHJldk1hbmlmZXN0KTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50TWFuaWZlc3QgPSB7IGlzbGFuZHM6IFtdLCByb3V0ZXM6IFtdIH07XG4gIH1cbiAgY29uc3QgbmV3TWFuaWZlc3QgPSBhd2FpdCBjb2xsZWN0KGRpcik7XG4gIERlbm8uZW52LnNldChcIkZSU0hfREVWX1BSRVZJT1VTX01BTklGRVNUXCIsIEpTT04uc3RyaW5naWZ5KG5ld01hbmlmZXN0KSk7XG5cbiAgY29uc3QgbWFuaWZlc3RDaGFuZ2VkID1cbiAgICAhYXJyYXlzRXF1YWwobmV3TWFuaWZlc3Qucm91dGVzLCBjdXJyZW50TWFuaWZlc3Qucm91dGVzKSB8fFxuICAgICFhcnJheXNFcXVhbChuZXdNYW5pZmVzdC5pc2xhbmRzLCBjdXJyZW50TWFuaWZlc3QuaXNsYW5kcyk7XG5cbiAgaWYgKG1hbmlmZXN0Q2hhbmdlZCkgYXdhaXQgZ2VuZXJhdGUoZGlyLCBuZXdNYW5pZmVzdCk7XG5cbiAgYXdhaXQgaW1wb3J0KGVudHJ5cG9pbnQpO1xufVxuXG5mdW5jdGlvbiBhcnJheXNFcXVhbDxUPihhOiBUW10sIGI6IFRbXSk6IGJvb2xlYW4ge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FDRSxPQUFPLEVBQ1AsT0FBTyxFQUNQLFdBQVcsRUFDWCxHQUFHLEVBQ0gsSUFBSSxFQUNKLFNBQVMsRUFDVCxJQUFJLFFBQ0MsWUFBWTtBQUNuQixTQUFTLEtBQUssUUFBUSxhQUFhO0FBRW5DLE1BQU0sbUJBQW1CO0FBRXpCLE9BQU8sU0FBUyx1QkFBdUI7SUFDckMsK0RBQStEO0lBQy9ELElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLElBQUksRUFBRSxtQkFBbUI7UUFDN0MsSUFBSSxVQUNGLENBQUMsYUFBYSxFQUFFLGlCQUFpQiwrQ0FBK0MsQ0FBQztRQUVuRixJQUFJLEtBQUssUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhO1lBQ3hDLFdBQ0U7UUFDSixPQUFPO1lBQ0wsV0FBVztRQUNiLENBQUM7UUFFRCxNQUFNO0lBQ1IsQ0FBQztBQUNILENBQUM7QUFPRCxPQUFPLGVBQWUsUUFBUSxTQUFpQixFQUFxQjtJQUNsRSxNQUFNLFlBQVksS0FBSyxXQUFXO0lBQ2xDLE1BQU0sYUFBYSxLQUFLLFdBQVc7SUFFbkMsTUFBTSxTQUFTLEVBQUU7SUFDakIsSUFBSTtRQUNGLE1BQU0sWUFBWSxVQUFVO1FBQzVCLDhEQUE4RDtRQUM5RCw2REFBNkQ7UUFDN0QsV0FBVyxNQUFNLEtBQUssS0FBSyxPQUFPLENBQUMsV0FBWTtRQUM3QyxhQUFhO1FBQ2Y7UUFDQSxNQUFNLGVBQWUsS0FBSyxXQUFXO1lBQ25DLGFBQWEsS0FBSztZQUNsQixjQUFjLElBQUk7WUFDbEIsTUFBTTtnQkFBQztnQkFBTztnQkFBTztnQkFBTTthQUFLO1FBQ2xDO1FBQ0EsV0FBVyxNQUFNLFNBQVMsYUFBYztZQUN0QyxJQUFJLE1BQU0sTUFBTSxFQUFFO2dCQUNoQixNQUFNLE9BQU8sVUFBVSxNQUFNLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUMvQyxVQUFVLElBQUksQ0FBQyxNQUFNO2dCQUV2QixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7UUFDSDtJQUNGLEVBQUUsT0FBTyxLQUFLO1FBQ1osSUFBSSxlQUFlLEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRTtRQUN2QyxjQUFjO1FBQ2hCLE9BQU87WUFDTCxNQUFNLElBQUk7UUFDWixDQUFDO0lBQ0g7SUFDQSxPQUFPLElBQUk7SUFFWCxNQUFNLFVBQVUsRUFBRTtJQUNsQixJQUFJO1FBQ0YsTUFBTSxhQUFhLFVBQVU7UUFDN0IsV0FBVyxNQUFNLFVBQVMsS0FBSyxPQUFPLENBQUMsWUFBYTtZQUNsRCxJQUFJLE9BQU0sV0FBVyxFQUFFO2dCQUNyQixNQUNFLENBQUMsb0JBQW9CLEVBQUUsT0FBTSxJQUFJLENBQUMsdUVBQXVFLENBQUM7WUFFOUcsQ0FBQztZQUNELElBQUksT0FBTSxNQUFNLEVBQUU7Z0JBQ2hCLE1BQU0sTUFBTSxRQUFRLE9BQU0sSUFBSTtnQkFDOUIsSUFBSSxDQUFDO29CQUFDO29CQUFRO29CQUFRO29CQUFPO2lCQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sUUFBUztnQkFDNUQsTUFBTSxPQUFPLEtBQUssWUFBWSxPQUFNLElBQUk7Z0JBQ3hDLE1BQU0sUUFBTyxVQUFVLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLElBQUksQ0FBQyxNQUFNO2dCQUNsRSxRQUFRLElBQUksQ0FBQztZQUNmLENBQUM7UUFDSDtJQUNGLEVBQUUsT0FBTyxNQUFLO1FBQ1osSUFBSSxnQkFBZSxLQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUU7UUFDdkMsY0FBYztRQUNoQixPQUFPO1lBQ0wsTUFBTSxLQUFJO1FBQ1osQ0FBQztJQUNIO0lBQ0EsUUFBUSxJQUFJO0lBRVosT0FBTztRQUFFO1FBQVE7SUFBUTtBQUMzQixDQUFDO0FBRUQsT0FBTyxlQUFlLFNBQVMsU0FBaUIsRUFBRSxRQUFrQixFQUFFO0lBQ3BFLE1BQU0sRUFBRSxPQUFNLEVBQUUsUUFBTyxFQUFFLEdBQUc7SUFFNUIsTUFBTSxTQUFTLENBQUM7Ozs7O0FBS2xCLEVBQ0ksT0FBTyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQU0sQ0FBQyxhQUFhLEVBQUUsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQ3ZFLE1BRUg7QUFDSCxFQUNJLFFBQVEsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFDbkUsSUFBSSxDQUFDLE1BQ1Q7Ozs7SUFJQyxFQUNBLE9BQU8sR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFNLENBQUMsRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFDbkUsSUFBSSxDQUFDLFVBQ1Q7OztJQUdDLEVBQ0EsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQU0sQ0FBQyxFQUFFLEtBQUssU0FBUyxDQUFDLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUN0RSxJQUFJLENBQUMsVUFDVDs7Ozs7OztBQU9ILENBQUM7SUFFQyxNQUFNLE9BQU8sS0FBSyxHQUFHLENBQUM7UUFDcEIsS0FBSztZQUFDLEtBQUssUUFBUTtZQUFJO1lBQU87U0FBSTtRQUNsQyxPQUFPO1FBQ1AsUUFBUTtRQUNSLFFBQVE7SUFDVjtJQUNBLE1BQU0sTUFBTSxJQUFJLGVBQWU7UUFDN0IsT0FBTSxVQUFVLEVBQUU7WUFDaEIsV0FBVyxPQUFPLENBQUMsSUFBSSxjQUFjLE1BQU0sQ0FBQztZQUM1QyxXQUFXLEtBQUs7UUFDbEI7SUFDRjtJQUNBLE1BQU0sSUFBSSxNQUFNLENBQUMsS0FBSyxLQUFLLENBQUMsUUFBUTtJQUNwQyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU07SUFDN0IsTUFBTSxLQUFLLE1BQU07SUFDakIsS0FBSyxLQUFLO0lBRVYsTUFBTSxjQUFjLElBQUksY0FBYyxNQUFNLENBQUM7SUFDN0MsTUFBTSxlQUFlLEtBQUssV0FBVztJQUVyQyxNQUFNLEtBQUssYUFBYSxDQUFDLGNBQWM7SUFDdkMsUUFBUSxHQUFHLENBQ1QsQ0FBQyxzQ0FBc0MsRUFBRSxPQUFPLE1BQU0sQ0FBQyxZQUFZLEVBQUUsUUFBUSxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQzlGO0FBRUosQ0FBQztBQUVELE9BQU8sZUFBZSxJQUFJLElBQVksRUFBRSxVQUFrQixFQUFFO0lBQzFEO0lBRUEsYUFBYSxJQUFJLElBQUksWUFBWSxNQUFNLElBQUk7SUFFM0MsTUFBTSxNQUFNLFFBQVEsWUFBWTtJQUVoQyxJQUFJO0lBQ0osTUFBTSxlQUFlLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNsQyxJQUFJLGNBQWM7UUFDaEIsa0JBQWtCLEtBQUssS0FBSyxDQUFDO0lBQy9CLE9BQU87UUFDTCxrQkFBa0I7WUFBRSxTQUFTLEVBQUU7WUFBRSxRQUFRLEVBQUU7UUFBQztJQUM5QyxDQUFDO0lBQ0QsTUFBTSxjQUFjLE1BQU0sUUFBUTtJQUNsQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsOEJBQThCLEtBQUssU0FBUyxDQUFDO0lBRTFELE1BQU0sa0JBQ0osQ0FBQyxZQUFZLFlBQVksTUFBTSxFQUFFLGdCQUFnQixNQUFNLEtBQ3ZELENBQUMsWUFBWSxZQUFZLE9BQU8sRUFBRSxnQkFBZ0IsT0FBTztJQUUzRCxJQUFJLGlCQUFpQixNQUFNLFNBQVMsS0FBSztJQUV6QyxNQUFNLE1BQU0sQ0FBQztBQUNmLENBQUM7QUFFRCxTQUFTLFlBQWUsQ0FBTSxFQUFFLENBQU0sRUFBVztJQUMvQyxJQUFJLEVBQUUsTUFBTSxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sS0FBSztJQUN2QyxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFHO1FBQ2pDLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLE9BQU8sS0FBSztJQUNqQztJQUNBLE9BQU8sSUFBSTtBQUNiIn0=